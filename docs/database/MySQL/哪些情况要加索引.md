## 数据检索
作为where条件时，例子：
```
select * from t9_1 where d = 90000;
```
在d字段上加索引，能显著提高查询速度

select 查询的字段
```
select d from t9_1;
```
在d字段上加索引，能显著提高查询速度

## 聚合函数
```
select max(d) from table1;
select min(d) from table1;
select count(*) from table1;
```

显然索引能提升 max() 函数的效率，同理也能提升 min() 函数的效率。

你是否有印象，我们在第 7 节中的 1.3 小节中有介绍 MySQL 5.7.18 之后版本的 count(*) 特点：从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 count(*) 语句，如果不存在二级索引，则扫描聚簇索引。原因是：InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。

因此索引对聚合函数 count(*) 也有优化作用。

## 排序字段

- 如果对单个字段排序，则可以在这个排序字段上添加索引来优化排序语句；
- 如果是多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句；
- 如果是先等值查询再排序，可以通过在条件字段和排序字段添加联合索引来优化排序语句。

## 避免回表

比如下面这条 SQL：
```
select a,d from t9_1 where a=90000;
```
可以走 a 字段的索引，但是在学了第 8 节后，我们知道了辅助索引的结构，如果通过辅助索引来寻找数据，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引回表去找对应的行数据。

但是，如果条件字段和需要查询的字段有联合索引的话，其实回表这一步就省了，因为联合索引中包含了这两个字段的值。像这种索引就已经覆盖了我们的查询需求的场景，我们称为：覆盖索引。比如下面这条 SQL：

```
select b,c from t9_1 where b=90000;
```

可直接通过联合索引 idx_b_c 找到 b、c 的值（联合索引详细讲解将放在第 11 节）。

所以可以通过添加覆盖索引让 SQL 不需要回表，从而减少树的搜索次数，让查询更快地返回结果

## 关联查询
关联查询其中一个优化方式就是：通过在关联字段添加索引，让 BNL变成 NLJ 或者 BKA