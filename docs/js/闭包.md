闭包是面试中常考的面试题之一了。考察的方式有两种，一种是比较直接的：直接问你闭包是什么；另一种更加常见：给你一段代码，问你执行结果，其实也是在变相考察闭包。

与闭包相关联的知识点：**作用域、作用域链、变量提升、暂时性死区、执行上下文。。。**

## 理解作用域的实现机制
几乎每一种编程语言，它最基本的能力都是能够存储变量当中的值、并且允许我们对这个变量的值进行访问和修改。那么有了变量之后，应该把它放在那里、程序如何找到它们？这是不是需要我们提前约定好一套存储变量、访问变量的规则？这套规则，就是我们常说的作用域。更多时候，我们提到作用域的时候，指的是这个规则约束下的一个变量、函数、标识符可以被访问的区域。

`var name = 'dayueba'` 是一条简单的声明语句，但是在js引擎里，它却包含了两个声明
- `var name` 编译时处理
- `name = 'dayueba` 运行时处理

这时大家会有一个疑问，JS 不是不存在编译阶段的 “动态语言” 吗？为啥会存在编译时和运行时。

其实，JS 也是有编译阶段的，它和传统语言的区别在于，JS 不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。

回到我们这个语句上来，我们来看看编译阶段和执行阶段阶段都发生了什么事情：

- 编译阶段： 编译阶段就需要 编译器 了。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段
- 执行阶段： 执行阶段需要的是 JS引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。

这里出现了一个有趣的东西，就是我们引擎的查找过程。这就引出了我们 JS 作用域里一个非常重要的概念 —— 作用域链。

## 作用域套作用域，就有了作用域链
现在我们已经知道，作用域本质上就是程序存储和访问变量的规则。现在，我们来看看，这套规则的内容具体是怎么回事儿。

在js里有三种作用域
- 全局作用域
- 函数作用域
- 块级作用域

**作用域链**

当需要访问某个变量时，如果在当前作用域里没有找到，会往更高的作用域里去查找。在这个查找过程中，层层递进的作用域，就形成了一条作用域链。

我们来看一个例子
```js
function addA(a) {
  console.log(a + b)
  console.log(c) // 报错
}

var b = 1

addA(2) //3
```
在这个例子中，有两个作用域：addA 的函数作用域和全局作用域。它们的关系示意如下：

![](https://img1.sycdn.imooc.com/5e5c808f00011e6608000614.png)

我们试图在 addA 这个函数里访问变量 b 的时候，考虑到函数作用域内并没有对 b、c 这两个变量作定义，所以一开始肯定是找不到的。要想找到 b、c ，该怎么做？就是我们上文提到的“探出头去”，对吧？探出头去，去上层作用域（全局作用域找），找到了 b ，那么就可以直接拿来用了；没找到 c，并且全局作用域已经没有上层作用域了（头探不出去了），那就歇菜，报错！这就是上文“执行阶段 ”里我们描述的那个过程。

在这个查找过程中，层层递进的作用域，就形成了一条作用域链。上面这个例子里，作用域链比较短：

![](https://img1.sycdn.imooc.com/5e5c809d000145c205640254.png)

## 理解闭包

从一个例子说起
```javascript
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6
```
在这个例子里，作用域的嵌套情况如下

![](https://img1.sycdn.imooc.com/5e5c80a90001d33508520636.png)

作用域链关系展示如下：

![](https://img1.sycdn.imooc.com/5e5ca90a000115ee09520278.png)

其中 add 这个函数，它嵌套在函数 addABC 的内部，想要查找 a、b、c 三个变量，它得去上层的 addABC 作用域里找，对吧？像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。

闭包让你可以在一个内层函数中访问到其外层函数的作用域。

<!-- ## 词法作用域和动态作用域

事实上，当我们在 JavaScript 语言的范畴里讨论“作用域”这个概念的时候，确实不需要区分它是“词法”还是“动态”，因为我们 JS 的作用域遵循的就是词法作用域模型。当面试官抛出“词法作用域 ”这个概念的时候，完全不用慌，它指的就是你最最熟悉的 JS 作用域。

但是站在语言的层面来看，作用域其实有两种主要的工作模型：

- 词法作用域：也称为静态作用域。这是最普遍的一种作用域模型，也是我们学习的重点
- 动态作用域：相对“冷门”，但确实有一些语言采纳的是动态作用域，如：Bash 脚本、Perl 等 -->

## 面试题
遇到一段代码里各种作用域的题目，也不用怕，按照作用域链画图即可解决。

拿一道题目举例

```javascript
var a = 1;
function test(){
    a = 2;
    return function(){
        console.log(a);
    }
    var a = 3;
}
test()();
```

开始画图
- 分层：我们从内向外画。最内层，是一个匿名函数。匿名函数的外层，是 test 函数的作用域，再外层，就是全局作用域了，我们先把这个层级关系画出来：
![](https://img1.sycdn.imooc.com/5e5cb0c10001704909220658.png)
- 找变量：这是这题的难点！全局变量里的 a =1 毫无疑问，最内层匿名函数里的 a 当前作用域不存在也毫无疑问；关键就是 test 函数里这个 a ，是啥情况？

 要分析出 test 函数里 a 的值，大家至少有两个知识点不能虚：

 - 变量提升：test 函数中，a = 2 在先， var a = 3 在后。但是！别忘了，函数作用域内部也是存在变量提升的，这个 var 会被提到函数的顶部，所以 test 函数体其实等价于下面这种情况：
```javascript
function test(){
    // 声明 var 被提前
    var a = 2;
    return function(){
        console.log(a);
    }
    a = 3;
}
```
- 作用域规则：结合我们 step1 里划分的层级和上一步分析出来的 test 函数中的变量情况，不难看出匿名函数实际拿到的 a 就是 test 作用域里的 a。那么这个 a 到底是 2 还是 3？这里需要大家牢记我们前面讲解中说过的一句话：我们作用域的划分，是在书写的过程中，根据你把它写在哪个位置来决定的。像这样划分出来的作用域，遵循的就是词法作用域模型。

这里我们匿名函数被定义的时候 a = 3 的赋值动作还没有发生（只有声明会被提前！），因此它拿到的 a 就是 2！

我们把我们分析出来的变量一个一个填进它们对应的地盘里：

![](https://img1.sycdn.imooc.com/5e5cb0cb00015eff08440666.png)

由此可以很清晰地捋出作用域链如下：

![](https://img1.sycdn.imooc.com/5e5cb0d4000168f409280320.png)

这道题的答案就是2。

## 闭包的应用
### 模拟私有变量
```javascript
// 利用闭包生成IIFE，返回 User 类
const User = (function() {
    // 定义私有变量_password
    let _password

    class User {
        constructor (username, password) {
            // 初始化私有变量_password
            _password = password
            this.username = username
        }

       login() {
           // 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码
           console.log(this.username, _password)
           // 使用 fetch 进行登录请求，同上，此处省略
       }
    }

    return User
})()

let user = new User('xiuyan', 'xiuyan123')

console.log(user.username)
console.log(user.password)
console.log(user._password)
user.login()
```
在这段代码中，我们把 _password 放在了 login 方法的外层函数作用域里，并通过立即执行 User 这个函数，创造出了一个闭包的作用域环境。

### 偏函数与柯里化
这两个都是函数式编程的概念，他们都是可以帮我们把需要多个入参的函数，转化为需要更少入参的函数的方法。

#### 柯里化
柯里化是把接受 n 个参数的 1 个函数改造为只接受 1个参数的 n 个互相嵌套的函数的过程。也就是 fn(a,b,c) 会变成 fn(a)(b)(c)。

demo:
```js
function generateName(prefix, type, itemName) {
    return prefix + type + itemName
}

// 柯里化
function generateName(prefix) {  
    return function(type) {
        return function (itemName) {
            return prefix + type + itemName
        }    
    }
}
```

#### 偏函数
偏函数是说，固定你函数的某一个或几个参数，然后返回一个新的函数（这个函数用于接收剩下的参数）。你有 10 个入参，你可以只固定 2 个入参，然后返回一个需要 8 个入参的函数 —— 偏函数应用是不强调 “单参数” 这个概念的。它的目标仅仅是把函数的入参拆解为两部分。

demo:
```js
function generateName(prefix, type, itemName) {
    return prefix + type + itemName
}

function generateName(prefix) {
    return function(type, itemName) {
        return prefix + type + itemName
    }
}
```