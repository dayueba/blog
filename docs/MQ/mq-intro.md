
## 消息队列的作用
### 异步（同步通信的问题）
比方说，系统里注册的逻辑是这样的：当我们注册成功后，需要向用户发一条注册成功或者营销的短信 和 给用户新手礼包。

那么伪代码大概像下面这样

```js
app.get('/register',  async () => {
  const userId = await authService.register();
  if (userId) {
    await smsServices.sendMessage();
    await giftServices.giveRegisterGift();
  }
})
```

<!-- 如果用户没有注册成功，那么不用执行下面的逻辑，一切正常。但是如果用户注册成功后，短信发送失败怎么办？赠送新手礼包失败怎么办？

最直观的思路就是重试

代码可能像下面这样，可以根据需要加上重试的次数

```js
async function sendMessage() {
  const success = await smsRpc.call()
  if (!success) {
    await smsRpc.call()
  }
}
``` -->

假设`authService.register()`,`smsServices.sendMessage()`和`giftServices.giveRegisterGift()`都只需要耗时50ms，那么这段逻辑一共需要耗时150ms

其中，除了`authService.register()`，另外两个方法是可以并行执行的，正常情况下可以减少50ms，总共也需要100ms。

上面是正常情况下，当`smsServices.sendMessage()` 或 `giftServices.giveRegisterGift()` 异常时，按照正常逻辑来讲，需要重试，当然也不可能无限重试，一般来说可以重试三次左右。假设这两个方法的都重拾了三次，在同步情况下，需要耗时350ms，这对用户体验来说是非常差的。对于用户来说，更想早点看到注册成功的消息，短信收不收到无所谓，新手礼包晚一分钟收到也不介意。

这个时候最好的办法就是，把要做的事，先存下来，直接返回结果，然后有专门的线程去处理存下来的事。我们可以用mysql，redis等实现相同的功能。但是如果这样做的，要考虑的反而更多了，比如如何确定消息存储成功，只存储了一次，消费成功，只消费了一次。为了解决这个问题，引入了更多的问题，显然不划算。此时就需要消息队列出马了。

#### QA
Q：为什么不直接在代码里异步处理，而需要用消息队列。

A：1. 消息队列可以持久化消息，后续可查看或者重复消费 2. 消息消费失败可以保存消息，后续处理 3. 可以保证消息按照顺序消费 4. 保护系统，不会同时存在大量的耗时的异步任务，防止出现因为异步任务导致的OOM 5. 方便扩展

### 解耦
> 对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。
首先，我们都知道，更新生产环境代码是一件非常麻烦的事，可能你得需要让同事review你的代码，需要去服务器或容器平台更新版本，或者你得在一周内的某个时间段才能发布。

假设你负责的用户系统，有一天，部门A要求，用户注册成功后，你得把用户注册信息也发给他们一份，然后你找他们要了一个接口，注册成功的时候调用他们的接口。

```js
app.get('/register',  async () => {
  const userId = await authService.register();
  if (userId) {
    await rpcA.call();
  }
})
```

你修改了代码，然后发了版本。过了一周，部门B也要求把用户注册信息也发给他们一份，你还是一样，去要了一个接口，然后修改代码，发版本。

```js
app.get('/register',  async () => {
  const userId = await authService.register();
  if (userId) {
    await rpcA.call();
    await rpcB.call();
  }
})
```

又过了一周，部门A说，不需要数据了，然后没办法，你去修改代码，毕竟没用的代码留着也不好。

### 限流

后端收到消息后将消息写入mq后可以立即返回提交成功（如果是订单：不要返回创建成功），当异步处理完成后可以用短信、app推送或者邮件通知用户。

在电商秒杀的场景中，将秒杀请求暂存于消息队列，业务服务器响应用户“秒杀结果正在处理中。。。”，释放系统资源去处理其它用户的请求。

削峰填谷，削平短暂的流量高峰，消息堆积会造成请求延迟处理，但秒杀用户对于短暂延迟有一定容忍度。

秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你
部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到
秒杀的结果，这是可以接受的。这时会并发 10 个请求到达数据库，并不会对数据库造成很大的压力。

## 消息队列的优/缺点

优点：系统间解耦，并具有一定的可恢复性，支持异构系统，下游通常可并发执行，系统具备弹
性。服务解耦、流量削峰填谷等

缺点：消息中间件存在一些瓶颈和一致性问题，对于开发来讲不直观且不易调试，有额外成本


## 如何自己实现一个简单的消息队列
我们可以通过阻塞队列来实现。
1. 当队列容器已满时生产者线程被阻塞，直到队列未满后才可以继续put；
2. 当队列容器为空时，消费者线程被阻塞，直至队列非空时才可以继续take。

但是这种肯定是不能放到生产环境的，比如没有集群，没有分布式，玩法太单一，不能满足企业级应用的要求。。。

而且：
1. 消息有没有持久化？
2. 怎么确定消息一定能发送成功？
3. 怎么确定消息一定能被消费成功？
4. 高并发下的性能怎么样？
5. 系统可靠吗？
6. 有没有Pub/Sub模式？
7. 有没有考虑过限流？


