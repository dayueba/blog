索引失效的就是指查询时有索引却不走索引，下面分享几种有索引却不走索引的情况

## 对条件字段做函数操作

### 场景重现
为了方便演示，先新建测试表
```
use temp;                       /* 使用temp这个database */

drop table if exists t3;        /* 如果表t3存在则删除表t3 */

CREATE TABLE `t3` (             /* 创建表t3 */
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a` varchar(20) DEFAULT NULL,
  `b` int(20) DEFAULT NULL,
  `c` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,  
  PRIMARY KEY (`id`),
  KEY `idx_a` (`a`) USING BTREE,
  KEY `idx_b` (`b`) USING BTREE,
  KEY `idx_c` (`c`) USING BTREE
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;

drop procedure if exists insert_t3; /* 如果存在存储过程insert_t3，则删除 */
delimiter ;;
create procedure insert_t3()        /* 创建存储过程insert_t3 */
begin
  declare i int;                    /* 声明变量i */
  set i=1;                          /* 设置i的初始值为1 */
  while(i<=10000)do                 /* 对满足i<=10000的值进行while循环 */
    insert into t3(a,b) values(i,i);  /* 写入表t3中a、b两个字段，值都为i当前的值 */
    set i=i+1;                        /* 将i加1 */
  end while;
end;;
delimiter ;
call insert_t3();                    /* 运行存储过程insert_t3 */

update t3 set c = '2019-05-22 00:00:00';  /* 更新表t3的c字段，值都为'2019-05-22 00:00:00' */
update t3 set c = '2019-05-21 00:00:00' where id=10000;	 /* 将id为10000的行的c字段改为与其它行都不一样的数据，以便后面实验使用 */
```

**对于上面创建的测试表，比如要查询测试表 t1 单独某一天的所有数据，SQL如下：**
```
select * from t3 where date(c) ='2019-05-21';
```

**然后我们使用explain来分析这条SQL的执行计划**
```
mysql> explain select * from t3 where date(c) ='2019-05-21';
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | t3    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

我们可以根据type为ALL，key为NULL判断出该 SQL 是没走索引的全表扫描

### 分析对条件字段做函数操作不走索引的原因

该例中 c 字段普通索引的 B+ 索引树如下，例子：

![](https://img.mukewang.com/5d3ad77b0001979814110615.png)

根据上面结构可以看到，索引树中存储的是列的实际值和主键值。如果拿 ‘2019-05-21’ 去匹配，将无法定位到索引树中的值。因此放弃走索引，而选择全表扫描。

### 优化sql，让索引生效
因此如果需要优化的话，改成 c 字段实际值相匹配的形式。因为 SQL 的目的是查询 2019-05-21 当天所有的记录，因此可以改成范围查询，如下：
```
select * from t1 where c>='2019-05-21 00:00:00' and c<='2019-05-21 23:59:59';
```
再用 explain 分析下执行计划：
```
mysql> explain select * from t3 where c>='2019-5-21 00:00:00' and c<='2019-5-21 23:59:59';
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t3    | NULL       | range | idx_c         | idx_c | 5       | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```
可以根据type=range key=idx_c rows=1 判断出 走了索引
> 经验分享：
>
> 类似求某一天或者某一个月数据的需求，建议写成类似上例的范围查询，可让查询能走索引。避免对条件索引字段做函数处理。
> 
> 我在工作中就曾经遇到过这类慢查询，如下：
> ```
> SELECT tml_num_id, status_num_id FROM sd_bl_so_tml_hdr WHERE 
> tenant_num_id = 6 AND data_sign = 0 AND sub_unit_num_id = 100004 AND 
> channel_num_id = 91 AND date_format(order_date, '%Y%m%d') = 
> date_format('2019-06-02', '%Y%m%d') AND status_num_id < 3 LIMIT 100;
> ```
> 如果明白了上面的优化技巧，可以尝试着改写优化这条 SQL。

## 隐式转换

### 认识隐式转换

> 什么时隐式转换？
>
> 当操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。某些转换是隐式的。
> 
> [关于隐式转换详情请参考MySQL官方手册](https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html)

隐式转换估计是很多 MySQL 使用者踩过的坑，比如联系方式字段。由于有时电话号码带加、减等特殊字符，有时需要以 0 开头，因此一般设计表时会使用 varchar 类型存储，并且会经常做为条件来查询数据，所以会添加索引。

而有时遇到需要按照手机号码条件（比如 11111111111）去查询数据时，因为查询者看到条件是一串数字，而忽视表中对应手机号字段是 varchar 类型，因此写出了如下不合理的SQL：

```
select user_name,tele_phone from user_info where tele_phone =11111111111; /* SQL 1 */
```

实际情况这条 SQL 查询效率是很低的。

### 场景重现

使用上面创建好的表，查询 a 字段等于 1000 的值，SQL如下：
```
mysql> select * from t3 where a=1000;
+------+------+------+---------------------+
| id   | a    | b    | c                   |
+------+------+------+---------------------+
| 1000 | 1000 | 1000 | 2019-05-22 00:00:00 |
+------+------+------+---------------------+
1 row in set (0.19 sec)
```

用explain分析，查看是否使用索引

```
mysql> explain select * from t3 where a=1000;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | t3    | NULL       | ALL  | idx_a         | NULL | NULL    | NULL | 10302 |    10.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
1 row in set, 3 warnings (0.02 sec)
```

通过 type 这列可以看到是最差的情况 ALL，通过 key 这列可以看到没走 a 字段的索引，通过 rows 这列可以看到进行了全表扫描。

### 不走索引的原因

a 字段类型是 varchar(20)，而语句中 a 字段条件值没加单引号，导致 MySQL 内部会先把a转换成int型，再去做判断，相当于实际执行的 SQL 语句如下：

```
mysql> select * from t3 where cast(a as signed int) =1000;
```

因此又回到上面说的：对索引字段做函数操作时，优化器会放弃使用索引

### 隐式转换的 SQL 优化
索引字符串列条件添加单引号，查看执行计划
```
mysql> explain select * from t3 where a='1000';
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t3    | NULL       | ref  | idx_a         | idx_a | 83      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.03 sec)
```

通过 type 这列，可以看到是 ref（基于普通索引的等值查询，比 ALL 性能好很多），通过key这列，可以看到已经走了 a 字段的索引，通过rows这列可以看到通过索引查询后就扫描了一行。

> 经验分享：
> 
> 隐式转换导致查询慢的情况在工作中遇到过几次，有时字段名对开发写SQL产生了影响，比如曾经遇到过字段名是user_num，而实际字段类型是char，但是开发在写SQL时误认为是int型，导致漏写单引号而发生隐式转换。所以建议在写SQL时，先看字段类型，然后根据字段类型写SQL。

## 模糊查询

### 场景重现
执行如下sql，使用全模糊的时候
```
mysql> select * from t3 where a like '%1111%';
+------+------+------+---------------------+
| id   | a    | b    | c                   |
+------+------+------+---------------------+
| 1111 | 1111 | 1111 | 2019-05-22 00:00:00 |
+------+------+------+---------------------+
1 row in set (0.01 sec)
```
使用explain分析，判断是否使用了索引

```
mysql> explain select * from t3 where a like '%1111%';
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | t3    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |    11.11 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

重点留意type、key、rows、Extra，发现是全表扫描。

### 优化建议
不使用左模糊，让模糊查询必须包含条件字段前面的值，然后落到数据库的查询为：
```
mysql> select * from t3 where a like '1111%';
+------+------+------+---------------------+
| id   | a    | b    | c                   |
+------+------+------+---------------------+
| 1111 | 1111 | 1111 | 2019-05-22 00:00:00 |
+------+------+------+---------------------+
1 row in set (0.02 sec)
```

现在使用explain分析，判断是否使用了索引

```
mysql> explain select * from t3 where a like '1111%';
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t3    | NULL       | range | idx_a         | idx_a | 83      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

> 经验分享：
> 
> 如果条件只知道中间的值，需要模糊查询去查，那就建议使用ElasticSearch或其它搜索服务器.

## 范围查询

### 场景重现

我们要在t3表中取出b字段1到2000范围数据，SQL 如下 ：

```
mysql> select * from t3 where b>=1 and b <=2000;
```

使用explain分析，判断是否使用了索引

```
mysql> explain select * from t3 where b>=1 and b <=2000;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | t3    | NULL       | ALL  | idx_b         | NULL | NULL    | NULL | 10302 |    19.41 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
可以发现并不能走b字段的索引。

### 不走索引的原因
优化器会根据检索比例、表大小、I/O块大小等进行评估是否使用索引。比如单次查询的数据量过大，优化器将不走索引。

### 优化范围查询

降低单次查询范围，分多次查询：
```
mysql> select * from t3 where b>=1 and b <=1000;
mysql> select * from t3 where b>=1001 and b <=2000;
```

查看执行计划（就只看第一条的，第二条同理）
```
mysql> explain select * from t3 where b>=1 and b <=1000;
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t3    | NULL       | range | idx_b         | idx_b | 5       | NULL | 1000 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

因此，降低查询范围后，能正常使用索引。

> 经验分享：
> 
> 实际这种范围查询而导致使用不了索引的场景经常出现，比如按照时间段抽取全量数据，每条SQL抽取一个月的；或者某张业务表历史数据的删除。遇到此类操作时，应该在执行之前对SQL做explain分析，确定能走索引，再进行操作，否则不但可能导致操作缓慢，在做更新或者删除时，甚至会导致表所有记录锁住，十分危险。

## 计算操作

### 场景重现

有时我们与有对条件字段做计算操作的需求，在使用 SQL 查询时，就应该小心了。先看下例：

```
mysql> explain select * from t3 where b-1 =1000;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | t3    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.03 sec)
```

### 索引失效原因

对索引字段做运算将使用不了索引

### 优化sql

将计算操作放在等号后面：

```
mysql> explain select * from t3 where b =1000+1;
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t3    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
```

发现能正常使用索引。

> 经验分享：
> 
> 一般需要对条件字段做计算时，建议通过程序代码实现，而不是通过MySQL实现。如果在MySQL中计算的情况避免不了，那必须把计算放在等号后面。

## 总结

为了避免写出不走索引的慢查询，该注意如下几点
- 应该避免隐式转换
- like查询不能以%开头
- 范围查询时，包含的数据比例不能太大
- 不建议对条件字段做运算及函数操作