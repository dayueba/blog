## 问题
很多时候，业务上会有分页操作的需求，对应的 SQL 类似下面这条：
```
select a,b,c from t9 limit 10000,10;
```

表示从表 t9 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。本节内容就一起研究下，是否有办法去优化分页查询

我先创建一张测试表  
```
CREATE TABLE `t9` (             /* 创建表t9 */
  `id` int(11) NOT NULL auto_increment,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_a` (`a`),
  KEY `idx_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;	

drop procedure if exists insert_t9; /* 如果存在存储过程insert_t9，则删除 */
delimiter ;;
create procedure insert_t9()        /* 创建存储过程insert_t9 */
begin
  declare i int;                    /* 声明变量i */
  set i=1;                          /* 设置i的初始值为1 */
  while(i<=100000)do                  /* 对满足i<=100000的值进行while循环 */
    insert into t9(a,b) values(i, i); /* 写入表t9中a、b两个字段，值都为i当前的值 */
    set i=i+1;                      /* 将i加1 */
  end while;
end;;
delimiter ;                 /* 创建批量写入100000条数据到表t9的存储过程insert_t9 */
call insert_t9();           /* 运行存储过程insert_t9 */
```

主要介绍两种分页场景的优化技巧：

- 根据自增且连续主键排序的分页查询
- 查询根据非主键字段排序的分页查询

## 根据自增且连续主键排序的分页查询

首先来看一个根据自增且连续主键排序的分页查询的例子：

```
mysql> select * from t9 limit 99000,2;
+-------+-------+-------+---------------------+---------------------+
| id    | a     | b     | create_time         | update_time         |
+-------+-------+-------+---------------------+---------------------+
| 99001 | 99001 | 99001 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
| 99002 | 99002 | 99002 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
+-------+-------+-------+---------------------+---------------------+
2 rows in set (0.09 sec)
```

该 SQL 表示查询从第 99001开始的两行数据，没添加单独 order by，表示通过主键排序。我们再看表 t1，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 99001开始的两行数据，如下：

```
mysql> select * from t9 where id >99000 limit 2;
+-------+-------+-------+---------------------+---------------------+
| id    | a     | b     | create_time         | update_time         |
+-------+-------+-------+---------------------+---------------------+
| 99001 | 99001 | 99001 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
| 99002 | 99002 | 99002 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
+-------+-------+-------+---------------------+---------------------+
2 rows in set (0.00 sec)
```

查询的结果是一致的。我们再对比一下执行计划：

```
mysql> explain select * from t9 limit 99000,2;
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
|  1 | SIMPLE      | t9    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100131 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from t9 where id >99000 limit 2;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t9    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1000 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

原 SQL 中 key 字段为 NULL，表示未走索引，rows 显示 99965，表示扫描的行数 99965行；

改写后的 SQL key 字段为 PRIMARY，表示走了主键索引，扫描了1000行。

显然改写后的 SQL 执行效率更高。

但是，这条 SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致.

另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：

- 主键自增且连续
- 结果是按照主键排序的

## 查询根据非主键字段排序的分页查询
再看一个根据非主键字段排序的分页查询，SQL 如下
```
mysql> select * from t9 order by a limit 99000,2;
+-------+-------+-------+---------------------+---------------------+
| id    | a     | b     | create_time         | update_time         |
+-------+-------+-------+---------------------+---------------------+
| 99001 | 99001 | 99001 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
| 99002 | 99002 | 99002 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 |
+-------+-------+-------+---------------------+---------------------+
2 rows in set (0.35 sec)
```

查看这条语句的执行计划
```
mysql> explain select * from t9 order by a limit 99000,2;
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | t9    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100131 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

发现并没有使用 a 字段的索引（key 字段对应的值为 null），具体原因就是不走索引的情况之一：扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引

知道不走索引的原因，那么怎么优化呢？

其实关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL 改写如下（这里参考了《深入浅出 MySQL》18.4.7 优化分页查询）：

```
mysql> select * from t9 f inner join (select id from t9 order by a limit 99000,2)g on f.id = g.id;
+-------+-------+-------+---------------------+---------------------+-------+
| id    | a     | b     | create_time         | update_time         | id    |
+-------+-------+-------+---------------------+---------------------+-------+
| 99001 | 99001 | 99001 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 | 99001 |
| 99002 | 99002 | 99002 | 2020-11-02 03:45:03 | 2020-11-02 03:45:03 | 99002 |
+-------+-------+-------+---------------------+---------------------+-------+
2 rows in set (0.12 sec)
```
我们明显可以看到执行时间便少了，再看一下执行计划
```
mysql> explain select * from t9 f inner join (select id from t9 order by a limit 99000,2)g on f.id = g.id;
+----+-------------+------------+------------+--------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 99002 |   100.00 | NULL        |
|  1 | PRIMARY     | f          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | g.id |     1 |   100.00 | NULL        |
|  2 | DERIVED     | t9         | NULL       | index  | NULL          | idx_a   | 5       | NULL | 99002 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+-------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)
```
原SQL使用的是filesort排序，而优化后的SQL使用的是索引排序。

## 总结
分页查询场景的优化：

- 根据自增且连续主键排序的分页查询优化
- 查询根据非主键字段排序的分页查询优化

对于其它一些复杂的分页查询，也基本可以按照这两个思路去优化，尤其是第二种优化方式。第一种优化方式需要主键连续，而主键连续对于一个正常业务表来说可能有点困难，总会有些数据行删除的，但是占用了一个主键 id。