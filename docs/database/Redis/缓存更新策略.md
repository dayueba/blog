**缓存一致性/缓存读写模式/更新策略**

下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。

**简介：**缓存更新是⼀个⾮常有趣的话题，关于如何更新缓存我们有很多种选择⽅式，⽐如先更新缓存，再更新 DB，或者是先更新 DB 再更新缓存，⼜或者是先更新 DB，后删除缓存，等等。每⼀种⽅式都会带来不同的结果，不存在最佳模式，我们需要做的事情就是根据⾃⾝的业务场景和对数据⼀致性的容忍程度，综合性地进⾏考量，选择适合自己的缓存读写模式。

## 缓存更新的常见方式

### 一、先更新DB再删除缓存 / Cache Aside Pattern（旁路缓存模式）


1. 写：更新 DB，然后直接删除 cache 。
2. 读：从 cache 中读取数据，读取到就直接返回，读取不到的话，就从 DB 中取数据返回，然后再把数据放到 cache 中。
Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。另外，Cache Aside Pattern 有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。

**Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。**

![](./img/184912a1-dd2f-4593-82ff-5d8a626cbf8b.png)

建议优先使用先更新数据库再删除缓存的办法，主要原因就有两个。
1. 先删缓存再更新数据库，有可能导致请求因缓存缺失而访问数据，给数据库带来压力。
2. 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置

Cache Aside Pattern 能够解决多数的不⼀致情况，或者说，在绝⼤多数场景下 Cache Aside Pattern 都能够保证良好的数据⼀致性。但是，在某些极端⾼并发的场景下，Cache Aside Pattern 仍然会导致数据不⼀致的情况

![](./img/screenshot-20220110-152907.png)

如上图所⽰，当 Thread B 读取数据时，由于 Thread A 删除 cache 过程结束，所以会发⽣ cache miss，Thread B 将从 DB 中取出数据，并 Load 进缓存中。若
此时⼜恰好有 Thread C 进⾏数据更新的话，那么就有可能导致 Thread C 在 Thread B 之前完成，Thread C 在 delete cache 时其实是删除了空数据，那么
Thread B Load 进缓存的数据其实是 Thread A 写⼊的旧数据，导致数据再次出现不⼀致

实际上，上述情况出现的条件⾮常苛刻，必须要在某⼀时间区间内同时存在两个或多个写⼊和多个读取。⽽⼀般业务场景下更新 DB + 删除缓存的操作通常能够在
200ms 以内返回，出现上述情况的概率极低

### 二、 先更新缓存，再同步更新 DB / Read/Write Through Pattern（读写穿透）

Read/Write Through 套路是：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。
1. 写（Write Through）：先查 cache，cache 中不存在，直接更新 DB。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。
2. 读(Read Through)： 从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。

Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。

和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。

### 三、先更新缓存，再异步更新 DB / Write Behind Pattern（异步缓存写入）
Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。

但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。

> Linux Page Cache 就是这么⼲的，在写⼊数据时，先将数据写⼊ Page Cache 中，然后再使⽤异步任务集中地将 Cache 数据写⼊硬盘中
> ![](./img/screenshot-20220110-151543.png)
> Linux 这样的写⼊⽅式能够有效地减轻硬盘的写⼊压⼒，并提⾼写⼊效率
> 
> 此时，缓存更多的是充当缓冲区的⾓⾊，‘cache’ 这⼀语义被弱化

Write Behind Pattern 下 DB 的写性能非常高，尤其适合一些数据经常变化的业务场景比如说一篇文章的点赞数量、阅读数量。 往常一篇文章被点赞 500 次的话，需要重复修改 500 次 DB，但是在 Write Behind Pattern 下可能只需要修改一次 DB 就可以了。

但是，这种模式同样也给 DB 和 Cache 一致性带来了新的考验，很多时候如果数据还没异步更新到 DB 的话，Cache 服务宕机就 gg 了。

最后再讨论下问什么不同步更新 DB。⼀⽅⾯是因为更新的数据可能需要进⾏额外的检查，⽐如唯⼀性检查。另⼀⽅⾯就是当 DB 更新失败以后，我们需要删除已更
新的缓存，避免出现脏数据，相当于做了⼀次 “⽆⽤功”

### 四、先更新 DB，再更新缓存
![](./img/screenshot-20220110-152407.png)
如上图所⽰，这种更新⽅式存在着严重的数据不⼀致问题。Thread A 明明先执⾏，但是却在 Thread B 执⾏完毕后才将缓存写⼊，即旧有的数据覆盖了最新修改的
数据，导致缓存和 DB 两者之间出现不⼀致的情况

### 五、先删除缓存，再更新 DB
![](./img/screenshot-20220110-152630.png)
先删除缓存，再更新 DB，在 DB 未更新成功之前，读取数据将会 miss cache，故⽽从 DB 中取数据，此时取出的数据为旧值。DB 更新完毕后，那么此时缓存中的
数据就是错误数据，并且会⼀直错到缓存过期或者是下⼀次的数据更新

## 延时双删
对于 Cache Aside Pattern 来说，在并发量较⾼的情况下可能会出现数据不⼀致的问题，如果我们能够保证缓存⼀定会被删除的话，就能够尽可能地缩短数据不⼀致 的窗⼝。最常⽤的⽅式就是延时双删，当删除完缓存以后，休眠⼀段时间，再进⾏删除。定时任务可由 MQ 或者是定时任务系统来完成

![](./img/e9754ad6-3857-4be9-af47-cf6349e50ac2.png)

此时我们能够将数据不⼀致的窗⼝缩短到⼀个⾮常短的时间，最⻓也就是 sleep 的时间

但是，延时双删虽然能够将数据不⼀致的窗⼝缩短，但是由于多删除了⼀次缓存，也就意味着在极端情况下 DB 的查询压⼒是原来的两倍，会有⼤量的查询直接 落⼊ DB 中，此时系统性能可能还不如双更新策略


## 订阅 binlog
采⽤订阅 binlog 的⽅式是⼀种看起来更美好的⽅式，⽆需在业务端对 Redis 进⾏任何的更新/删除动作，所有的更新都交由 binlog 订阅线程处理。

之所以说看起来很美好的原因在于解析 binlog 以及如何更新缓存会⽐较复杂，并且对业务架构的前期设计要求很⾼，并且订阅 binlog 通常会引⼊额外的 MQ 中间 件，编码更为复杂


## 参考
- https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AD%96%E7%95%A5.pdf
