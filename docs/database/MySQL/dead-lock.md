死锁这个概念最早出现于操作系统中，指的是两个进程持有对方想要的资源，但是又都不会释放这些资源，那么，就只能无止境的等待。

在 MySQL 中，我们说的死锁是事务相关的，所以，不同的存储引擎死锁的产生条件和解决办法也是不相同的。由于我们基本只使用InnoDB存储引擎，所以我们也只关注在 InnoDB 中，死锁是怎么出现的，又怎样去避免和解决它。

## 死锁产生的必要条件
操作系统中死锁产生的必要条件是以下四个
- 互斥条件：某个资源在同一时刻只能被一个进程占有
- 不可剥夺条件：一个进程占有的资源，在没有使用完之前，不能被其他的进程抢占
- 请求与保持条件：一个进程因请求资源阻塞时，对自己占据的资源不释放
- 循环等待条件：若干个进程之间形成了一种头尾相接的循环等待资源关系

**我们可以相应得出InnoDB 中，死锁产生的比较条件**
- 至少存在两个并发事务
- 每个事务都持有锁资源，但是都不会释放
- 每个事务都在申请新的锁资源
- 事务之间形成了锁资源的循环等待

所谓必要条件，就是要同时满足，那么，我们也可以得到启发：打破死锁的关系，只需要让以上的四个条件不同时满足就可以了。

数据库死锁的影响是非常大的，在生产环境中，几乎是致命的，随时可能会导致系统崩溃。例如，某张表由于各种原因出现了死锁，那么，所有涉及这张表的操作都会被阻塞，不论读写。这就会使很多操作在队列里排队，占用宝贵的数据库连接。最终会导致数据库连接耗尽、各种操作超时等等，致使系统各项指标异常，进而引发系统崩溃。

我们在工作中遇到的死锁，绝大多数都是 “唯一键”（列值唯一）引起的。

## 死锁的产生的情况一：表锁导致的死锁
**产生原因：**用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图
访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要
等用户A释放表A才能继续，这就死锁就产生了。

用户A -> A表（表锁）-> B表（表锁）

用户B -> B表（表锁）-> A表（表锁）

**解决方案：**这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分
析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个
资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任
何时刻都应该按照相同的顺序来锁定资源。


## 行锁导致死锁的情况一

**产生原因：**如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等
价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发
生阻塞或死锁。

**解决方案：**SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划"对SQL语句进行分析，对于
有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。

## 使用行锁模拟死锁产生的情况

![](4d0eeec7b136371b79248a0aed005a52.jpeg)

这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

innodb_lock_wait_timeout的值设置的太长和太短都不合适，太长的话我们需要等待太久，太短的话容易把普通的锁等待当成死锁处理。所以我们一般采用第二种方法：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n^2)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。

## 死锁的产生的情况四：共享锁转换为排他锁

**产生原因:** 事务A 查询一条纪录，然后更新该条纪录；此时事务B 也更新该条纪录，这时事务B 的排他锁由于
事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待。事务A 再执行更新操作时，
此处发生死锁，因为事务A 需要排他锁来做更新操作。但是，无法授予该锁请求，因为事务B 已经
有一个排他锁请求，并且正在等待事务A 释放其共享锁。

```sql
# 事务A
select * from dept where deptno=1 lock in share mode; //共享锁,1
update dept set dname='java' where deptno=1;//排他锁,3

# 事务B
update dept set dname='Java' where deptno=1;//由于1有共享锁，没法获取排他锁，需等待，2
```

**解决办法：**
1. 对于按钮等控件，点击立刻失效，不让用户重复点击，避免引发同时对同一条记录多次操作；
2. 使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量
下的系统性能。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用
户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中；

## 死锁检测的时间复杂度

**这里我们着重的对死锁检测的时间复杂度进行一个基本的分析**

![](img/screenshot-20220119-162912.png)

如上图所示，假设每一个该 DAG 中每一个节点都表示一个事务，方向则表示依赖，也就是等待该事务 commit。当我们每新增一个事务时，都需要去该图
中判断是否因为自身的加入而形成的环，有向图环检测的时间复杂度为 O(V+E)，即必须遍历所有节点才能得知是否有环。因此，死锁检测的整体时间复杂
度为 O(E*V*V)

当然，并不是所有新加入的事务都需要进行死锁检测，而是只在当前事务被阻塞时才会进行 deadlock detect，并且也并不需要扫描全部的事务，只需要
在一个链路上进行扫描即可

但是存在一个极端情况，就是所有的事务都去更新同一行
数据，那么此时 DAG 就可能变成了一个链表

![](img/screenshot-20220119-163130.png)

此时环检测的平均时间复杂度就变成了 O(n^2)，n 为并发执行的事务数量

也就是说，假如有 100 个事务同时更新同一行数据，死锁检测需要遍历
1 + 2 + 3 + 4 + ... + 100 = 5050 次才能结束

## 减少死锁检测带来的代价

**那么该如何减少死锁检测带来的代价呢？**
- 降低并发
    - 最实用的方式还是降低修改同一条语句的事务的并发执行度，也就是原本有100 个事务并发执行，通过业务层的处理，将其降低成5个或者10个事务并发执行
    - 此时只能通过数据库中间件来完成，也就是对更新同一行数据的事务进行排队处理
- 拆分逻辑
    - 对热点数据进行拆分，比如将一行拆成多行数据，业务在更新数据时随机地选择一条数据进行更新，读取数据时再进行汇总
    - 这种方式其实也是减少对同一条数据的并发更新数量

其实乐观锁也可以避免死锁的发生，只不过乐观锁适用于读多写少、并且事务执行比较简短的情况。同时，也需要对原有的业务代码进行修改

## 降低死锁出现的概率的使用建议
1. 加锁顺序⼀致，，尽可能⼀次性锁定所有所需的数据⾏；
2. 加锁索引准确，缩⼩锁定范围，尽量基于 primary 或 unique key 更新数据。
3. 单次操作数据量不宜过多，涉及表尽量少。
4. 减少表上索引，减少锁定资源。
