> MySQL 中，锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。
> 根据加锁的范围,可分为:全局锁,表锁以及行锁 

## 全局锁
MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：
```
FLUSH TABLES WITH READ LOCK;
```

简称：FTWRL，可以使用下面命令解锁：
```
UNLOCK TABLES;
```

下面通过一个例子理解一下全局锁：

首先创建测试表，并写入数据：
```
drop table if exists t14;
CREATE TABLE `t14` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_a` (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
insert into t14(a,b) values(1,1);
```

进行 FTWRL 实验：

当session1执行FTWRL后，session1上的更新会报错，其它session更新的会被阻塞。

当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。

### 使用场景
那么全局锁一般什么时候会用到呢？
全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。

好在 mysqldump 包含一个参数 --single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。

而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 --master-data，可以避免使用全局锁。

## 表级锁
表级锁有两种：表锁和元数据锁。

### 表锁

#### 使用场景
- 事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；
- 事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。

表锁又分为表读锁和表写锁，命令分别是：

**表读锁：**
```
lock tables t14 read;
```
对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。

**表写锁**
```
lock tables t14  write;
```
对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞

### 元数据锁
在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 [bug#989](https://bugs.mysql.com/bug.php?id=989)。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》[MySQL · 特性分析 · MDL 实现分析](http://mysql.taobao.org/monthly/2015/11/04/)。

从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。

但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：


我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。

当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。

## 行锁

> MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：
> 
> - InnoDB 支持事务：适合在并发条件下要求数据一致的场景。
> - InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。

### 两阶段锁
传统的关系型数据库加锁的一个原则是：两阶段锁原则。

两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。

我们可以通过下面这张表理解两阶段锁：
序号	MySQL 操作	解释	锁阶段
1	begin;	事务开始	
2	insert into …;	加 insert 对应的锁	加锁阶段
3	update table …;	加 update 对应的锁	加锁阶段
4	delete from …;	加 delete 对应的锁	加锁阶段
5	commit;	事务结束，同时释放 2、3、4 步骤中加的锁	解锁阶段

### InnoDB 行锁模式
InnoDB 实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；(给某一行数据加共享锁后，其它事务不能给该条数据加排他锁)
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。(给某一行数据加排他锁锁后，其它事务不能给该条数据加排他锁以及共享锁)

对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：

- 共享锁（S）：select * from table_name where … lock in share mode;
- 排他锁（X）：select * from table_name where … for update。


### InnoDB 行锁算法
InnoDB 行锁的三种算法：

- Record Lock：单个记录上的索引加锁。
- Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。
- Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。

InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。