重点学习行锁和表锁，这也是面试中比较容易考的

这里需要说明下，每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。

## 全局锁
全局锁就是对整个数据库实例加锁。以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份**。也就是把整库每个表都select出来存成文本。

要是为了导出整个库而导致线上业务停摆，这是无法接受的，那我们该怎么导出数据呢？

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。需要注意的是，**single-transaction方法只适用于所有的表使用事务引擎的库。**

## 表级锁
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

**可以得出加读锁时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。加写锁时，本线程可以读写，其它线程读写都会阻塞。**

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

但是由于锁定粒度很大，它的实现会简单许多，资源消耗也会很低，不光是 InnoDB ，其他大部分的存储引擎也都支持表级锁，它具有如下特点：
1. 由于开销比较小，加锁会很快
2. 锁定粒度大，所以锁冲突的概率高，并发度低
3. 不会出现死锁

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。尽量升级成InnoDB存储引擎，使用行锁。

另一类表级的锁是MDL（metadata lock)。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

## 行锁

行级锁是 MySQL 中锁定粒度最细的一种锁，它锁住的是行记录。行级锁可以大大减少数据库操作的冲突，但是加锁的开销也是非常大的。它具有如下特点：
1. 由于开销比较大，加锁会很慢
2. 锁定粒度小，所以锁冲突的概率低，并发度高
3. 可能会出现死锁
在InnoDB事务中，行锁是在需要的时候才加上的，而不是事务开始时获取，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，以减少锁的持有时间，从而提高事务的并发度。

### 死锁

使用行锁模拟死锁产生的情况
![](4d0eeec7b136371b79248a0aed005a52.jpeg)

这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

innodb_lock_wait_timeout的值设置的太长和太短都不合适，太长的话我们需要等待太久，太短的话容易把普通的锁等待当成死锁处理。所以我们一般采用第二种方法：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n^2)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。

那么该如何减少死锁检测带来的代价呢？
- 降低并发
    - 最实用的方式还是降低修改同一条语句的事务的并发执行度，也就是原本有100 个事务并发执行，通过业务层的处理，将其降低成5个或者10个事务并发执行
    - 此时只能通过数据库中间件来完成，也就是对更新同一行数据的事务进行排队处理
- 拆分逻辑
    - 对热点数据进行拆分，比如将一行拆成多行数据，业务在更新数据时随机地选择一条数据进行更新，读取数据时再进行汇总
    - 这种方式其实也是减少对同一条数据的并发更新数量

其实乐观锁也可以避免死锁的发生，只不过乐观锁适用于读多写少、并且事务执行比较简短的情况。同时，也需要对原有的业务代码进行修改

### InnoDB 行锁模式
InnoDB 实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；(给某一行数据加共享锁后，其它事务不能给该条数据加排他锁)
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。(给某一行数据加排他锁锁后，其它事务不能给该条数据加排他锁以及共享锁)

对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：

- 共享锁（S）：select * from table_name where … lock in share mode;
- 排他锁（X）：select * from table_name where … for update。

### InnoDB 行锁算法

InnoDB 行锁的三种算法：
- Record Lock：单个记录上的索引加锁。
- Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。
- Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。
InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。


## 其它锁
除了上面介绍的锁以外我们还可以在页和区粒度上锁定数据，对应页锁和区锁。只不过两种锁InnoDB都不支持，所以重要性没那么大。

页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。
![](lock.pn)

## mysql是如何选择表级锁和行级锁的
刚刚说过，InnoDB 存储引擎支持行和表级锁，那么，什么场景下会锁住行、什么场景下又会锁住表呢？把这个问题搞清楚了，也就基本上掌握了这两种锁，在实际的应用中，也就可以把握程序的性能了。
InnoDB 行级锁是通过给索引上的索引项加锁来实现的，所以，只有通过索引条件检索的数据，InnoDB 才会使用行级锁。否则，使用表级锁。总结下来：
- 不通过索引条件查询时，InnoDB 一定会使用表锁，而不是行锁（因为没有索引只能全表扫描）
- 查询时，不论是使用主键索引、唯一索引或者普通的索引，InnoDB 都会使用行锁来对数据加锁
但是，需要注意，对于第二条总结，在有些特殊情况下是不成立的。例如，对于数据量很少的表，MySQL 会认为全表扫描更快，此时，即使使用索引字段查询，InnoDB 也会使用表锁，而不是行锁。因此，如果想确定当前使用的是哪一种锁，检查下 SQL 的执行计划（EXPLAIN），确认是否在查询时使用了索引。