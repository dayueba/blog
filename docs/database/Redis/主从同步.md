Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的模式。

## 修改配置文件，开启主动同步
在从库的`redis.conf`里添加如下配置
```
replicaof 127.0.0.1 6379 # 主库ip与端口
masterauth 123456 # 主库密码 有需要的话添加
replica-read-only yes # 从节点只读模式
```

也直接使用`slaveof`命令

## 主从库之间的第一次同步 - 全量同步
![](b413f7ec-0d86-4ae8-bbe7-906c12a5ad6d.png)

**第一阶段：建立连接，为全量复制做准备**。从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令参数来启动复制。psync命令包含了主库的runID和复制进度offset两个参数。
- runID：runID 是Redis 在启动后所自动生成的一个唯一标识ID，称之为runID。runID 实际上是一个随机生成的、长度为40 的十六进制字符，在Redis 运行期间可能会多次生成runID。在主从建立之初，从节点并不知道主节点的runID，所以只能给一个 「?」
- offset：offset 则是从节点复制的偏移量，表示从节点此时的复制进度。初次建立主从复制时，还没有复制任何东西，也就是没有偏移量，所以使用 「-1」表示

主库在收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后会记录下这两个参数。

**第二阶段：主库将所有的数据同步给从库。从库收到数据后，在本地完成数据加载。**

具体步骤：主库执行bgsave命令，生成RDB文件，然后将文件发送给从库。从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。

主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。但是这段时间的里新写入的数据并没有记录到刚生成的RDB文件中。为了保证主从的数据一致性，主库会在内存中使用专门的`replication buffer`(后续增量复制也是使用`replication buffer`)，记录RDB文件生成后收到的所有写操作，这部分数据将会在第三阶段中同步。

如果ReplicationBuffer 已满，那么Master 会断开与Slave的连接，重新开始全量复制。所以，如果ReplicationBuffer 设置的太小的话将会导致恶性循环

**第三阶段，也是最后一个阶段：主库会把第二步骤中的`replication buffer`发送给从库，从节点加载完成后，第一次同步过程全部完成。**


## 增量复制
Master 将Replication Buffer 的数据持续地发送给Slave节点，此时为增量的数据。

可以通过`info replication`命令，返回的`slave_repl_offset`，`master_repl_offset`字段查看偏移量。

![](d39d6e8d-9f3f-40de-b051-3411c5fb1fe6.png)

## Slave重启了，是否会进行全量复制?
Redis 会持久化runID 和offset 这两个关键信息，重启后直接载入，并向Master 节点发送psync{runID}{offset}。若此时Master 中backlogbuffer 中offset 的位置还没有被覆盖的话，那么可以进行增量同步。否则，仍然进行全量同步


## 过期key的处理
slave不会让key过期，而是等待master让key过期。当master让key过期时，会发送一个del命令到从库。

## 无磁盘化复制
由于主库执行bgsave是先把数据持久化到磁盘，如果磁盘性能很差，那么会消耗大量时间，在配置文件中找到`repl-diskless-sync`，把值改为yes，开启无磁盘化复制。

但是配置文件中也有说明，无磁盘化复制属于实验功能，生产环境看自己情况要不要开启。

## 主从延迟导致的脏数据怎么解决
预警：编写外部程序监听主从节点的复制偏移量，延迟较大时发出报警。

1. 忽略
2. 选择性强制读主库
3. 对于设置了过期时间的，Redis会检查过期时间来判断是否返回数据


## 参考资料
- [官方文档](http://www.redis.cn/topics/replication.html)
- [](https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/redis/Redis%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.pdf)